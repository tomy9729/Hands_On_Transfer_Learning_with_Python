## 5\. 탐색적 데이터 분석

EDA는 머신러닝 프로젝트에서 처음에 하는 작업 중 하나다. 데이터 이해는 데이터에 대한 다양한 통찰력을 얻고 비즈니스 요구사항과 비즈니스 상황을 더 잘 이해하기 위한 중요한 단계다. 

먼저 필요한 라이브러리르 가져오고 환경을 설정한다.

```
import numpy as np
import pandas as pd
from collections import Counter

#시각화
import seaborn as sns
import matplotlib.pyplot as plt

#params 세팅
params = {'legend.fontsize' : 'x-large',
          'figure.figsize' : (30,10),
          'axes.labelsize' : 'x-large',
          'axes.titlesize' : 'x-large',
          'xtick.labelsize' : 'x-large',
          'ytick.labelsize' : 'x-large'}

sns.set_style('whitegrid')
sns.set_context('talk')

plt.rcParams.update(params)
```

세팅과 필요한 라이브러리가 갖춰지면 데이터에만 집중할 수 있다. 탐색적 분석을 하려는 데이터 세트는 battle.csv로 왕좌의 게임의 주요 전투가 수록돼있다. 데이터 세트는 다음과 같다. 

```
battles_df = pd.read_csv('battles.csv')
battles_df
```

[##_Image|kage@bwfMYk/btqVTHYL33l/KKiwK0lkopXxKzfHVv74kk/img.png|alignCenter|width="732" height="NaN" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|battle.csv 샘플||_##]

다음과 같이 총 행의 개수, 각 속성의 데이터 타입, 각 수치 속성의 일반 통계를 볼 수 있는데, 판다스의 유틸리티인 shape과 dtypes,describe()를 사용했다. 데이터 세트에는 38개의 전투에 대한 데이터가 있으며 각 전투는 25개의 속성으로 설명돼있다.

```
sns.countplot(y='year', data=battles_df)
plt.title('Battle Distribution over Years')
plt.show()
```

[##_Image|kage@DK2Vm/btqVSuyFzTK/tNjkRWES9b6KL7RJXQRud0/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|&nbsp;여러 해에 걸친 전투의 분포||_##]

왕좌의 게임에서는 상상할 수 있는 모든 장소에서 전투가 발생하므로 전투 지역은 다양하다. 여기서 선호나는 지역이 어디였는지 알아보는 것은 흥미로울 것이다. 

```
sns.countplot(x = 'region', data=battles_df)
plt.title('Battles by Regions')
plt.show()
```

[##_Image|kage@cLiqw0/btqVQXBk0Oa/IiooH6Du71ejQbiJ9tGCh1/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|지역별 전투||_##]

주목할만한 또 하나의 흥미로운 점은 장벽을 넘는 전투가 단 한 번 있었다는 것이다. 이와 유사한 분석을 알기 위해 집단을 다양한 방식으로 나눠 볼 수 있다.

다음으로 어떤 왕이 가장 많은 공격을 시도했는지 알아보자. 전투에 참여한 각 왕의 비율을 알기 위해 원형 차트를 사용해 시각화한다. 여기서는 왕들의 공격에 관한 분석을 하고 있지만 왕들의 방어에 대해서도 같은 방법을 사용할 수 있다.

```
attacker_king = battles_df.attacker_king.value_counts()
attacker_king.name = ''  # y-axis-label을 off로 해도 된다.
attacker_king.plot.pie(figsize=(6,6),autopct = '%.2f')
```

[##_Image|kage@dmkc9A/btqV0791CRO/2yKT3BLHVXEl8VSW5RhxY0/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|왕별로 공격한 전투||_##]

웨스테로스와 에소스의 땅은 적들과 온갖 위협 때문에 위험하다. 각 왕이 몇 번이나 승리했는지 데이터를 좀 더 분석해보자. 왕들은 자신의 영지를 방어하거나 권력을 위해 공격을 시도할 수도 있기 때문에 각 공방에서 승리했는지를 보는 것도 흥미로울 것이다. 다음은 각 왕의 공격과 수비의 성공 현황을 분석할 수 있는 누적 막대 차트를 만드는 코드다. 

```
attack_winners = battles_df[battles_df.\
                            attacker_outcome=='win']\
                                ['attacker_king'].\
                                value_counts().\
                                reset_index()

attack_winners.rename(
    columns={'index':'king',
             'attacker_king':'wins'},
             inplace = True)

attack_winners.loc[:,'win_type'] = 'attack'

defend_winners = battles_df[battles_df.\
                            attacker_outcome == 'loss']\
                            ['defender_king'].\
                            value_counts().\
                            reset_index()

defend_winners.rename(
    columns = {'index':'king',
               'defender_king' : 'wins'},
               inplace=True)

defend_winners.loc[:,'win_type'] = 'defend'

sns.barplot(x="king",
            y="wins",
            hue = "win_type",
            data=pd.concat([attack_winners,
                            defend_winners]))
plt.title('King and Their Wins')
plt.ylabel('wins')
plt.xlabel('king')
plt.show()
```

이 코드는 각 왕이 공격으로 승리한 횟수와 수비에서 승리한 횟수를 계산한 것이다.

[##_Image|kage@bBLOZ7/btqVZR7Jsen/dkptMKssrbyKdhNa1XpGQ1/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|왕별로 승리한 횟수||_##]

이 그래프를 통해 바라테온 가문이 수비뿐만 아니라 공격에서도 가장 많은 승리를 궈뒀음을 알 수 있다. 로브 스타크가 두 번 째로 성공한 왕이었다.

또한 데이터 세트에는 참여 가문의 수, 전투 지휘관, 군의 규모를 설명하는 속성이 포함돼 있다. 전투를 더 잘 이해하기 위해 심층적이고 유사한 분석을 할 수 있다. 다음으로 왕좌의 게임에서 가장 크게 대립하는 왕들이 누구인지 알아보자.

```
# 대립하는 왕들
temp_df = battles_df.dropna(
    subset = ["attacker_king","defender_king"])[
              ["attacker_king","defender_king"]
              ]
archenemy_df = pd.DataFrame(
    list(Counter(
        [tuple(set(king_pair))
        for king_pair in temp_df.values
         if len(set(king_pair))>1]).\
          items()),
        columns=['king_pair',
                 'battle_count'])
archenemy_df['versus_text'] = archenemy_df.\
                                apply(
                                    lambda row : 
                                    '{} Vs {}'.format(row['king_pair'][0], row['king_pair'][1]),axis=1)
archenemy_df.sort_values('battle_count',
                         inplace = True,
                         ascending = False)

archenemy_df[['versus_text','battle_count']].set_index('versus_text',inplace = True)

sns.barplot(data = archenemy_df,
            x = 'versus_text',
            y = 'battle_count')

plt.xticks(rotation = 45)
plt.xlabel('Arechenemies')
plt.ylabel('Number of Battles')
plt.title('Archenemies')
plt.show()
```

먼저 임시 데이터 프레임을 준비하고 공격하거나 방어한 왕의 이름이 기재되지 않은 전투를 제거한다. 정제된 데이터 프레임이 준비되면 행마다 전투에 참여한 대립쌍을 전부 세어본다. 전투 가운데 동일한 왕의 군대끼리 내전한 경우는 무시한다. 그런 다음 막대그래프를 출력한다. 

[##_Image|kage@lEEBh/btqVZS6Fc27/W8RwRjbMNIoBKj1wvFNAxk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]

예상대로 로브스타크와 조프리 바라테온이 10번이 넘는 전투를 치렀으며, 다른 쌍은 5번 이하이다. 

이번 절에서 다른 분석과 시각화는 데이터 세트에서 할 수 있는 작업을 간략하게 보여준다. 이 데이터 세트 하나에서도 도출할 수 있는 패턴과 통찰이 더 많이 존재할 것이다. 

EDA는 머신러닝의 다른 단계로 진입하기 전에 데이터 세트를 자세히 이해하기 위한 매우 강력한 메커니즘이다. 이어지는 장에서는 모델링, 튜닝, 평가, 배포 단계로 들어가기 전에 비즈니스 문제를 이해하는 데 도움이 되도록 데이터 세트를 통해 EDA를 규칙적으로 수행할 것이다.
